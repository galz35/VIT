ğŸ“˜ PARTE 1.3 â€“ SincronizaciÃ³n Offline y GestiÃ³n de Rutas GPS
ğŸ§³ 1.3.1 â€“ Estrategia Offline (Flutter App)

La app mÃ³vil debe operar en modo offline-first, sincronizando datos en background cuando haya conexiÃ³n.

ğŸ”„ Mecanismo de SincronizaciÃ³n
Elemento	Tipo	DescripciÃ³n
SQLite (local)	Base de datos persistente	Tareas, formularios, usuarios, logs, tracking
SyncTable	Auxiliar	Marca entidades locales con status: PENDING / SYNCED / ERROR
SyncManager	Servicio Flutter	EnvÃ­a lotes a la API y actualiza estado
RetryQueue	FIFO local	Cola para reintentos de fallos de red
ğŸ§ª Estrategia Recomendada

Cualquier acciÃ³n offline crea un registro con pending = 1

El SyncManager corre cada 1 min (conectividad) o manualmente

La API NestJS recibe paquetes por lotes (/api/sync)

Cada entidad tiene campo external_id para reconciliaciÃ³n

ğŸ“¦ 1.3.2 â€“ Estructura de Tablas Locales
Tabla	Campos claves
actividades	id_local, id_remoto, cliente_id, estado, fecha
formularios_local	id_local, form_id, respuestas, adjuntos
tracking_points	lat, lng, velocidad, precision, ts_local
sync_table	entidad, id_local, intento, estado, payload
ğŸ“¡ 1.3.3 â€“ Tracking GPS con PrecisiÃ³n
ğŸ“ Registro de puntos

Se usa geolocator o flutter_background_service

Se toma posiciÃ³n cada X metros o cada N segundos (segÃºn config)

Se graba lat, lng, velocidad, accuracy, batteryLevel, timestamp

âš™ï¸ ParÃ¡metros configurables
ParÃ¡metro	DescripciÃ³n
minDistanceMeters	Evita puntos redundantes en zonas estÃ¡ticas
intervalMs	Cada cuÃ¡ntos milisegundos captar posiciÃ³n
accuracy	best, balanced, lowPower, etc.
geofenceRadius	Radio mÃ­nimo para marcar â€œllegada a clienteâ€
ğŸ“ˆ 1.3.4 â€“ CÃ¡lculo de Distancia Diaria
ğŸ§  LÃ³gica recomendada (server-side)

Recibe puntos GPS con timestamp, lat, lng

Elimina ruido (saltos de precisiÃ³n > 50m en 1s)

Ordena por tiempo

Calcula la distancia total con Haversine entre cada punto vÃ¡lido

Suma solo si:

Diferencia entre puntos > 5m y < 1km

Tiempo entre puntos < 5 min

function distanciaTotal(puntos[]) {
  total = 0
  for (i = 1; i < puntos.length; i++) {
    if (valid(puntos[i-1], puntos[i])) {
      total += haversine(puntos[i-1], puntos[i])
    }
  }
  return total
}

ğŸ§² 1.3.5 â€“ DetecciÃ³n de Llegada/Salida (Geofencing)

Cada cliente tiene lat, lng, radio

Cada vez que se sincroniza una posiciÃ³n:

Se calcula si estÃ¡ dentro del radio (geocerca)

Si antes estaba fuera y ahora dentro â†’ evento ENTRADA

Si antes estaba dentro y ahora fuera â†’ evento SALIDA

isInsideGeofence(lat, lng, cliente) {
  return haversine(lat, lng, cliente.lat, cliente.lng) <= cliente.radio
}

âš ï¸ 1.3.6 â€“ Alertas AutomÃ¡ticas
Tipo de alerta	Disparador
No llegÃ³ al cliente	No hay check-in en las primeras 2 horas
Se saliÃ³ de la zona	SALIDA sin completar formulario
Inactividad	No hay tracking > 30 min
Distancia insuficiente	Distancia del dÃ­a < X km esperados

Las alertas se calculan en el worker backend, no en la app mÃ³vil.

ğŸš¦ 1.3.7 â€“ Eventos de Usuario con Metadata
AcciÃ³n	Metadata capturada
Check-in	lat, lng, battery, signal, device_id, photo?
EnvÃ­o formulario	form_id, respuestas, adjuntos, ubicaciÃ³n
BotÃ³n de pÃ¡nico	ubicaciÃ³n, hora, mensaje, nivel

Todo se centraliza en tabla evento_usuario para auditorÃ­a.